import UIKit
import RxSwift
import RxCocoa

class ChocolatesOfTheWorldViewController: UIViewController {
  @IBOutlet private var cartButton: UIBarButtonItem!
  @IBOutlet private var tableView: UITableView!
  // You’ll use to clean up any Observers you set up.
  private let disposeBag = DisposeBag()
  // just(_:) indicates that there won’t be any changes to the underlying value of the Observable, but that you still want to access it as an Observable value.
  let europeanChocolates = Observable.just(Chocolate.ofEurope)
}

//MARK: View Lifecycle
extension ChocolatesOfTheWorldViewController {
  override func viewDidLoad() {
    super.viewDidLoad()
    title = "Chocolate!!!"
    
    setupCartObserver()
    setupCellConfiguration()
    setupCellTapHandling()
  }
}

//MARK: - Rx Setup
private extension ChocolatesOfTheWorldViewController {
  // This sets up a reactive Observer to update the cart automatically.
  func setupCartObserver() {
    //1: Grab the shopping cart’s chocolates variable as an Observable.
    ShoppingCart.sharedCart.chocolates.asObservable()
      .subscribe(onNext: { //2: Call subscribe(onNext:) on that Observable to discover changes to the Observable’s value. subscribe(onNext:) accepts a closure that executes every time the value changes. The incoming parameter to the closure is the new value of your Observable. You’ll keep getting these notifications until you either unsubscribe or dispose of your subscription. What you get back from this method is an Observer conforming to Disposable.
        [unowned self] chocolates in
        self.cartButton.title = "\(chocolates.count) \u{1f36b}"
      })
      .disposed(by: disposeBag) //3: Add the Observer from the previous step to your disposeBag. This disposes of your subscription upon deallocating the subscribing object.
  }
  
  // The values normally generated by tableView(_:numberOfRowsInSection:) and numberOfSections(in:) are now automatically calculated based on the observed data. The closure effectively replaces tableView(_:cellForRowAt:).
  func setupCellConfiguration() {
    //1: Call bind(to:) to associate the europeanChocolates observable with the code that executes each row in the table view.
    europeanChocolates
      .bind(to: tableView
        .rx //2: By calling rx, you access the RxCocoa extensions for the relevant class. In this case, it’s a UITableView.
        .items(cellIdentifier: ChocolateCell.Identifier,
               cellType: ChocolateCell.self)) { //3: Call the Rx method items(cellIdentifier:cellType:), passing in the cell identifier and the class of the cell type you want to use. The Rx framework calls the dequeuing methods as though your table view had its original data source.
                row, chocolate, cell in
                cell.configureWithChocolate(chocolate: chocolate) //4: Pass in a block for each new item. Information about the row, the chocolate at that row and the cell will return
      }
      .disposed(by: disposeBag) //5: Take the Disposable returned by bind(to:) and add it to the disposeBag.
  }
  
  // To remedy this, there’s another extension method RxCocoa adds to UITableView called modelSelected(_:). This returns an Observable you can use to watch information about selected model objects.
  func setupCellTapHandling() {
    tableView
      .rx
      .modelSelected(Chocolate.self) //1: Call the table view’s reactive extension’s modelSelected(_:), passing in the Chocolate model type to get the proper type of item back. This returns an Observable.
      .subscribe(onNext: { [unowned self] chocolate in // 2: Taking that Observable, call subscribe(onNext:), passing in a closure of what should be done any time a model is selected (i.e., a cell is tapped).
        let newValue =  ShoppingCart.sharedCart.chocolates.value + [chocolate]
        ShoppingCart.sharedCart.chocolates.accept(newValue) //3: Within the closure passed to subscribe(onNext:), add the selected chocolate to the cart.
          
        if let selectedRowIndexPath = self.tableView.indexPathForSelectedRow {
          self.tableView.deselectRow(at: selectedRowIndexPath, animated: true)
        } //4: Also in the closure, deselect the tapped row.
      })
      .disposed(by: disposeBag) //5: subscribe(onNext:) returns a Disposable. Add it to the disposeBag.
  }
  
}

// MARK: - Table view data source


// MARK: - Table view delegate


// MARK: - SegueHandler
extension ChocolatesOfTheWorldViewController: SegueHandler {
  enum SegueIdentifier: String {
    case goToCart
  }
}
